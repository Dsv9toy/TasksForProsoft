     1                                  ; Second homeWork Part 1.
     2                                  ; task: Необходимо перевернуть строку (например abc->bca)
     3                                  ; 1 - Строка попадает через терминал
     4                                  ; 2 - Строка сохраняется в регистре
     5                                  ; 3 - Создается функция которая берет из регистра строку, переворачивает ее и сохраняет новый результат
     6                                  ; 4 - Печать перевернутой строки на экран
     7                                  
     8                                  ; #Данный алгоритм напоминает работу стека. Печатаем слева направо, а считываем справа налево(с конца)
     9                                  ; #Будем использовать его.
    10                                  ; Сначала печатаем приветствие -> Ждем ввод в консоль -> Переворачиваем строку -> Выводим результат
    11                                  
    12                                  
    13                                  section .data  ; секция данных
    14                                  
    15 00000000 D09CD0B0D0B3D0B8D1-     EnterMessage db 'Магический разворот строки: ', 0    ; строка для вывода на консоль
    15 00000009 87D0B5D181D0BAD0B8-
    15 00000012 D0B920D180D0B0D0B7-
    15 0000001B D0B2D0BED180D0BED1-
    15 00000024 8220D181D182D180D0-
    15 0000002D BED0BAD0B83A2000   
    16                                  EnterMessageLen equ $ - EnterMessage 
    17 00000035 0A00                    nextLine db 10, 0  ; Для перехода на новую строку
    18                                  
    19                                  
    20                                  section .bss ; Секция неинициализируемых данных. Для буферов ввода/вывода объявим
    21                                  
    22 00000000 <res 64h>               inputBuff resb 100 ; сюда строку
    23 00000064 <res 64h>               outputBuff resb 100 ; сюда будет вывод 
    24                                  
    25                                  
    26                                  section .text ; секция для кода
    27                                  
    28                                      global _start ; делаем метку метку _start видимой извне
    29                                  
    30                                  ;---------------------------------------------Функция вывода сообщения-----------------
    31                                  PrintEnterMsg:
    32 00000000 50                          push rax ; Сохраняем состояние тк он исп-ся для системных вызовов
    33 00000001 57                          push rdi ; Сохраняем состояние тк он исп-ся для определения назначения данных. 
    34                                      
    35 00000002 B801000000                  mov rax, 1 ; говорим - Переводись в состояние записи write
    36 00000007 BF01000000                  mov rdi, 1 ; 1 - значит на экран(stdout)
    37                                  
    38                                  ; RSI и RDX писать не надо так как они уже передались как параметры из секции .data
    39                                  
    40 0000000C 0F05                        syscall  
    41                                  
    42 0000000E 5F                          pop rdi
    43 0000000F 58                          pop rax ; вернули всё на место
    44                                  
    45 00000010 C3                      ret
    46                                  
    47                                  ;--------------------------------------------Функция чтения введенной строки.-----------------------------------
    48                                  ReadImputStrFunc:
    49 00000011 57                          push rdi ; Сохраняем состояние тк он исп-ся для определения назначения данных. 
    50                                  
    51 00000012 B800000000                  mov rax, 0 ; Говорим - rax, теперь читай данные 
    52 00000017 BF00000000                  mov rdi, 0 ; Откуда? - с командной строки
    53                                  
    54                                  ; RSI и RDX писать не надо так как они уже передались
    55                                  
    56 0000001C 0F05                        syscall
    57                                  
    58 0000001E 5F                          pop rdi ; вернули всё на место    
    59                                  
    60 0000001F C3                      ret
    61                                  
    62                                  ;--------------------------------------------Функция преобразования строки в обратную через стек--------------------------
    63                                  ReverseStrFunc:
    64                                  ; Перебросим данные в стек. Надо сделать так, чтобы данные передавались посимвольно дабы их было возможно развернуть.
    65                                  ; Для этого создадим цикл, который будет перебрасывать всё что не приколочено, пока данные не закончатся.
    66                                      pushLoop: ; Создадим метку.
    67 00000020 480FB606                        movzx rax, byte [rsi] ; В rax передается байт того что лежит в переменной с адресом, хранящемся в rsi
    68 00000024 50                              push rax ; Пускаем его в стек
    69                                  
    70 00000025 48FFC6                          inc rsi ; Читаем след значение. inc - тоже самое что из плюсов Инкремент. Некий rsi++ в мире ассемблера
    71                                  
    72 00000028 E2F6                            loop pushLoop ; Что-то вроде умного счётчика. Спец команда для циклов. Работает только с RCX. Удобно. Если не с RCX то пришлось бы использовать ручной метод с jmpz
    73                                      
    74 0000002A 4C89C1                      mov rcx, r8 ; После цикла длина слова уменьшилась до нуля(Команда loop его изничтожила). Надо вернуть опять длину слова.
    75                                      ; r8 пусть отвечает за счёт
    76                                  
    77                                      ; Достанем из стека то что закинули
    78                                      popLoop:
    79 0000002D 58                              pop rax 
    80                                  
    81 0000002E 8807                            mov [rdi], AL ; Оказывается если вместо AL испол-ть rax - то будет запись 8 байтов, а надо 1 всего.
    82                                          ; То есть хотели БУКВА, а записали БУКВА 0 0 0 0 0 и так далее. То есть испортили сколько-то ячеек. Нам младщий байт только записать надо.
    83 00000030 48FFC7                          inc rdi
    84 00000033 E2F8                            loop popLoop ; Работаем RCX раз
    85 00000035 C3                      ret
    86                                  
    87                                  _start:   ;---------------------------------------------------- Точка входа в программу-----------------------------------
    88                                      ;Входное описание программы
    89 00000036 48BE-                       mov rsi, EnterMessage 
    89 00000038 [0000000000000000] 
    90 00000040 BA35000000                  mov rdx, EnterMessageLen 
    91 00000045 E8B6FFFFFF                  call PrintEnterMsg
    92                                  
    93                                      ;Ввод пользователем строки
    94 0000004A 48BE-                       mov rsi, inputBuff
    94 0000004C [0000000000000000] 
    95 00000054 BA64000000                  mov rdx, 100 ; 100 символов для длины
    96 00000059 E8B3FFFFFF                  call ReadImputStrFunc
    97                                  
    98 0000005E 4989C0                      mov r8, rax ; Пусть в r8 будет храниться длина !!!!!
    99 00000061 49FFC8                      dec r8 ; Оказывается В rax хранится символ переноса строки, удалим его. Декремент из плюсов сменил имидж, теперь он dec 
   100                                  
   101                                      ;Сальто-Переворот строки
   102                                                  ;Запишем всё что понадобится для функции
   103 00000064 48BE-                       mov rsi, inputBuff   ; В RSI будет адрес исходной строки
   103 00000066 [0000000000000000] 
   104 0000006E 48BF-                       mov rdi, outputBuff ; а тут то что на выходе
   104 00000070 [6400000000000000] 
   105                                  
   106 00000078 4C89C1                      mov rcx, r8
   107 0000007B E8A0FFFFFF                  call ReverseStrFunc
   108                                  
   109                                      ;Вывод результата
   110 00000080 48BE-                       mov rsi, outputBuff
   110 00000082 [6400000000000000] 
   111 0000008A 4C89C2                      mov rdx, r8
   112 0000008D E86EFFFFFF                  call PrintEnterMsg
   113                                  
   114                                              ;Перенесем курсор на след строку
   115 00000092 48BE-                       mov rsi, nextLine
   115 00000094 [3500000000000000] 
   116 0000009C BA01000000                  mov rdx, 1
   117 000000A1 E85AFFFFFF                  call PrintEnterMsg
   118                                  
   119                                      ;Ну и всё на сегодня. Выходим
   120 000000A6 B83C000000                  mov rax, 60  ; exit
   121 000000AB 4831FF                      xor rdi, rdi ; код возврата чтобы 0 был. успешный
   122 000000AE 0F05                        syscall 
   123                                  
   124                                  
