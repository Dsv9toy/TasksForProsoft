; Second homeWork Part 1.
; task: Необходимо перевернуть строку (например abc->bca)
; 1 - Строка попадает через терминал
; 2 - Строка сохраняется в регистре
; 3 - Создается функция которая берет из регистра строку, переворачивает ее и сохраняет новый результат
; 4 - Печать перевернутой строки на экран

; #Данный алгоритм напоминает работу стека. Печатаем слева направо, а считываем справа налево(с конца)
; #Будем использовать его.
; Сначала печатаем приветствие -> Ждем ввод в консоль -> Переворачиваем строку -> Выводим результат


section .data  ; секция данных

EnterMessage db 'Магический разворот строки: ', 0    ; строка для вывода на консоль
EnterMessageLen equ $ - EnterMessage 
nextLine db 10, 0  ; Для перехода на новую строку


section .bss ; Секция неинициализируемых данных. Для буферов ввода/вывода объявим

inputBuff resb 100 ; сюда строку
outputBuff resb 100 ; сюда будет вывод 


section .text ; секция для кода

    global _start ; делаем метку метку _start видимой извне

;---------------------------------------------Функция вывода сообщения-----------------
PrintEnterMsg:
    push rax ; Сохраняем состояние тк он исп-ся для системных вызовов
    push rdi ; Сохраняем состояние тк он исп-ся для определения назначения данных. 
    
    mov rax, 1 ; говорим - Переводись в состояние записи write
    mov rdi, 1 ; 1 - значит на экран(stdout)

; RSI и RDX писать не надо так как они уже передались как параметры из секции .data

    syscall  

    pop rdi
    pop rax ; вернули всё на место

ret

;--------------------------------------------Функция чтения введенной строки.-----------------------------------
ReadImputStrFunc:
    push rdi ; Сохраняем состояние тк он исп-ся для определения назначения данных. 

    mov rax, 0 ; Говорим - rax, теперь читай данные 
    mov rdi, 0 ; Откуда? - с командной строки

; RSI и RDX писать не надо так как они уже передались

    syscall

    pop rdi ; вернули всё на место    

ret

;--------------------------------------------Функция преобразования строки в обратную через стек--------------------------
ReverseStrFunc:
; Перебросим данные в стек. Надо сделать так, чтобы данные передавались посимвольно дабы их было возможно развернуть.
; Для этого создадим цикл, который будет перебрасывать всё что не приколочено, пока данные не закончатся.
    pushLoop: ; Создадим метку.
        movzx rax, byte [rsi] ; В rax передается байт того что лежит в переменной с адресом, хранящемся в rsi
        push rax ; Пускаем его в стек

        inc rsi ; Читаем след значение. inc - тоже самое что из плюсов Инкремент. Некий rsi++ в мире ассемблера

        loop pushLoop ; Что-то вроде умного счётчика. Спец команда для циклов. Работает только с RCX. Удобно. Если не с RCX то пришлось бы использовать ручной метод с jmpz
    
    mov rcx, r8 ; После цикла длина слова уменьшилась до нуля(Команда loop его изничтожила). Надо вернуть опять длину слова.
    ; r8 пусть отвечает за счёт

    ; Достанем из стека то что закинули
    popLoop:
        pop rax 

        mov [rdi], AL ; Оказывается если вместо AL испол-ть rax - то будет запись 8 байтов, а надо 1 всего.
        ; То есть хотели БУКВА, а записали БУКВА 0 0 0 0 0 и так далее. То есть испортили сколько-то ячеек. Нам младщий байт только записать надо.
        inc rdi
        loop popLoop ; Работаем RCX раз
ret

_start:   ;---------------------------------------------------- Точка входа в программу-----------------------------------
    ;Входное описание программы
    mov rsi, EnterMessage 
    mov rdx, EnterMessageLen 
    call PrintEnterMsg

    ;Ввод пользователем строки
    mov rsi, inputBuff
    mov rdx, 100 ; 100 символов для длины
    call ReadImputStrFunc

    mov r8, rax ; Пусть в r8 будет храниться длина !!!!!
    dec r8 ; Оказывается В rax хранится символ переноса строки, удалим его. Декремент из плюсов сменил имидж, теперь он dec 

    ;Сальто-Переворот строки
                ;Запишем всё что понадобится для функции
    mov rsi, inputBuff   ; В RSI будет адрес исходной строки
    mov rdi, outputBuff ; а тут то что на выходе

    mov rcx, r8
    call ReverseStrFunc

    ;Вывод результата
    mov rsi, outputBuff
    mov rdx, r8
    call PrintEnterMsg

            ;Перенесем курсор на след строку
    mov rsi, nextLine
    mov rdx, 1
    call PrintEnterMsg

    ;Ну и всё на сегодня. Выходим
    mov rax, 60  ; exit
    xor rdi, rdi ; код возврата чтобы 0 был. успешный
    syscall 


